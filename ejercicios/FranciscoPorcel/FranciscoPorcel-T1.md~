# Tema 1

## Ejercicio 1

#### Consultar en el catálogo de alguna tienda de informática el precio de un ordenador tipo servidor y calcular su coste de amortización a cuatro y siete años.

En primer lugar consultamos el precio del ordenador tipo servidor. En [PCComponentes](http://www.pccomponentes.com/hp_proliant_ml310e_g8_xe_e3_1220_8gb_2tb.html?gclid=COOf7pHbm8ECFSXHtAodpjkA8w) podemos encontrar un servidor con un precio de 644 euros. 

Ese será el precio con IVA, por lo que habrá que restarselo. DE esta forma, el precio que podremos amortizar será:

644 - (21% de 644) = 508.76 euros

### Amortización en 4 años (suponiendo como fecha de compra el 1 de enero):

Como podemos leer en la fuente sugerida en la práctica, podemos amortizar cada año un 25% del precio inicial del servidor. Por ello, la amortización a cuatro años consistiría en cubrir cada año un 25% del precio. De esta manera:

* 25% en 2014 = 127.19 euros
* 25% en 2015 = 127.19 euros
* 25% en 2016 = 127.19 euros
* 25% en 2017 = 127.19 euros

### Amortización en 7 años (suponiendo como fecha de compra el 1 de enero):

En este caso, nos interesará deducir un mayor porcentaje del precio en los primeros años, ya que al principio es cuando hacemos la inversión. De esta forma podríamos deducir cada año de la siguiente forma:

* 25% en 2014 = 127.19 euros
* 25% en 2015 = 127.19 euros
* 15% en 2016 = 76.314 euros
* 15% en 2017 = 76.314 euros
* 10% en 2018 = 50.876 euros
* 5% en 2019 = 25.438 euros
* 5% en 2020 = 25,438 euros

## Ejercicio 2

#### Usando las tablas de precios de servicios de alojamiento en Internet y de proveedores de servicios en la nube, comparar el coste durante un año de un ordenador con un procesador estándar (escogerlo de forma que sea el mismo tipo de procesador en los dos vendedores) y con el resto de las características similares (tamaño de disco duro equivalente a transferencia de disco duro) si la infraestructura comprada se usa sólo el 1% o el 10% del tiempo.

Vamos a comparar el precio con los porcentajes de uso especificados entre este [servidor cloud](http://aws.amazon.com/es/ec2/pricing/) de amazon y este [servidor cloud](http://azure.microsoft.com/es-es/pricing/details/cloud-services/) de Azure.

Las características del servidor amazon son:

* RAM = 4GB
* Disco duro =  220GB
* Cores = 2 cores
* Precio por hora = 0,04 euros

Las características del servidor azure son:

* RAM = 3.5GB
* Disco duro =  135GB
* Cores = 2 cores
* Precio por hora = 0,1192

### Para un uso de un 1% en un año:

En este caso el número de horas que pagaríamos sería: 
- 1% de (24 horas * 365 días) = 87.6 horas

Por tanto tendríamos un precio total para ambas opciones de:

* Servidor azure = 87.6 horas * 0.1341 euros = 11.74716 euros
* Servidor amazon = 87.6 horas * 0.04 euros =  3.504 euros

### Para un uso de un 10% en un año:

En este caso el número de horas que pagaríamos sería: 
- 10% de (24 horas * 365 días) =  876 horas

Por tanto tendríamos un precio total para ambas opciones de:

* Servidor VPS = 876 horas * 0.1341 euros =  117.4716 euros
* Servidor cloud = 876 horas * 0.04 euros = 35.504 euros

Como podemos observar, el precio de amazon es casi tres veces mejor que el de azure, teniendo amazon unas prestaciones algo superiores.

## Ejercicio 3

#### 1. ¿Qué tipo de virtualización usarías en cada caso? Comentar en el foro. (¿Qué tipo de virtualización es la más adecuada para: alojar varios clientes en un sólo servidor, crear un sistema eficiente de web + middleware + base de datos, un sistema de prueba de software e integración continua? Responder aquí y razonar.)

![Respuesta en el foro](https://github.com/FranciscoPorcel/GII-2014/blob/master/ejercicios/FranciscoPorcel/imagenes/Tema1/3_1.png)


#### 2. Crear un programa simple en cualquier lenguaje interpretado para Linux, empaquetarlo con CDE y probarlo en diferentes distribuciones.


## Ejercicio 4

#### Hacer el tutorial de línea de órdenes de docker para comprender cómo funciona.

Después de realizar el tutorial nos sale un mensaje de felicitación:

![Mensaje de felicitación](https://github.com/FranciscoPorcel/GII-2014/blob/master/ejercicios/FranciscoPorcel/imagenes/Tema1/4.png)

## Ejercicio 5

#### Instala el sistema de gestión de fuentes git

Hacemos esto mediante la orden:

* sudo apt-get install git

Una vez hecho esto, debemos clonar la carpeta de GitHub en nuestro ordenador. Para ello ponemos "git clone " y a continuación el enlace a nuestro GitHub. En mi caso:

* git clone [https://github.com/FranciscoPorcel/GII-2014.git](https://github.com/FranciscoPorcel/GII-2014.git)


## Ejercicio 6

#### Crear un proyecto y descargárselo con git. Al crearlo se marca la opción de incluir el fichero README. Modificar el readme y subir el fichero modificado.

En primer lugar creamos el nuevo proyecto. En mi caso lo he nombrado "Nuevo Proyecto".

![Creación de un nuevo proyecto](https://github.com/FranciscoPorcel/GII-2014/blob/master/ejercicios/FranciscoPorcel/imagenes/Tema1/6_1.png)

A continuación nos descargamos la carpeta a nuestro pc.

![Descarga de los archivos](https://github.com/FranciscoPorcel/GII-2014/blob/master/ejercicios/FranciscoPorcel/imagenes/Tema1/6_2.png)

Modificamos el archivo README.md.

![Modificación del archivo README.md](https://github.com/FranciscoPorcel/GII-2014/blob/master/ejercicios/FranciscoPorcel/imagenes/Tema1/6_3.png)

Subimos la carpeta modificada a GitHub.

![Subimos la carpeta a GitHub](https://github.com/FranciscoPorcel/GII-2014/blob/master/ejercicios/FranciscoPorcel/imagenes/Tema1/6_4.png)

Como podemos observar, los cambios se han realizado:

![Cambios realizados en GitHub](https://github.com/FranciscoPorcel/GII-2014/blob/master/ejercicios/FranciscoPorcel/imagenes/Tema1/6_5.png)


## Ejercicio 7

#### Comprobar si en la instalación hecha se ha instalado cgroups y en qué punto está montado, así como qué contiene. 

Mi sistema operativo es Ubuntu 14.04 y como se comenta en la documentación cgroups está montado en /sys/fs/cgroup. Esta carpeta contiene una serie de archivos que permiten controlar y monitorizar la actividad de los diferentes grupos de control.

![Punto de montaje de cgroups](https://github.com/FranciscoPorcel/GII-2014/blob/master/ejercicios/FranciscoPorcel/imagenes/Tema1/7_1.png)


## Ejercicio 8

#### 1. Crear diferentes grupos de control sobre un sistema operativo Linux. Ejecutar en uno de ellos el navegador, en otro un procesador de textos y en uno último cualquier otro proceso. Comparar el uso de recursos de unos y otros durante un tiempo determinado.

En primer lugar he creado tres grupos de control:

![Grupos de control](https://github.com/FranciscoPorcel/GII-2014/blob/master/ejercicios/FranciscoPorcel/imagenes/Tema1/8_1.png)

Una vez hecho esto le asigno al primer grupo el proceso de "mozilla" (número 2529), al segundo grupo el procesador de textos (número 10593) y al tercero el el proceso del spotify (número 2749).


#### 2. Calcular el coste real de uso de recursos de un ordenador teniendo en cuenta sus costes de amortización. Añadir los costes eléctricos correspondientes.

## Ejercicio 9

#### 1. Discutir diferentes escenarios de limitación de uso de recursos o de asignación de los mismos a una u otra CPU.
    
#### 2. Implementar usando el fichero de configuración de cgcreate una política que dé menos prioridad a los procesos de usuario que a los procesos del sistema (o viceversa).

#### 3. Usar un programa que muestre en tiempo real la carga del sistema tal como htopy comprobar los efectos de la migración en tiempo real de una tarea pesada de un procesador a otro (si se tiene dos núcleos en el sistema).

#### 4. Configurar un servidor para que el servidor web que se ejecute reciba mayor prioridad de entrada/salida que el resto de los usuarios.

## Ejercicio 10

#### Comprobar si el procesador o procesadores instalados tienen estos flags. ¿Qué modelo de procesador es? ¿Qué aparece como salida de esa orden?

Mi procesador es un Intel Core 2 Duo. Como salida de la orden aparece la línea en la que se encuentra el flag "vmx". Como mi procesador no es AMD el flag svm no aparece.

![Flags activos](https://github.com/FranciscoPorcel/GII-2014/blob/master/ejercicios/FranciscoPorcel/imagenes/Tema1/10_1.png)

## Ejercicio 11

#### Comprobar si el núcleo instalado en tu ordenador contiene este módulo del kernel usando la orden kvm-ok.

Ejecutamos la orden y nos muestra lo siguiente:

![kvm-ok](https://github.com/FranciscoPorcel/GII-2014/blob/master/ejercicios/FranciscoPorcel/imagenes/Tema1/11_1.png)

Por lo cual mi ordenador no contiene este módulo kernel.

## Ejercicio 12

#### Comentar diferentes soluciones de Software as a Service de uso habitual

![Comentario en el foro](https://github.com/FranciscoPorcel/GII-2014/blob/master/ejercicios/FranciscoPorcel/imagenes/Tema1/12_1.png)

# Tema 2

## Ejercicio 1

#### Instalar un entorno virtual para tu lenguaje de programación favorito (uno de los mencionados arriba, obviamente).

Voy a instalar el entorno "virtualenv":

![Instalando virtualenv](https://github.com/FranciscoPorcel/GII-2014/blob/master/ejercicios/FranciscoPorcel/imagenes/Tema2/1_1.png)

## Ejercicio 2

#### Darse de alta en algún servicio PaaS tal como Heroku, Nodejitsu u OpenShift.

Me doy de alta en "OpenShift":

![Instalando virtualenv](https://github.com/FranciscoPorcel/GII-2014/blob/master/ejercicios/FranciscoPorcel/imagenes/Tema2/2_1.png)

## Ejercicio 3

#### Crear una aplicación en OpenShift y dentro de ella instalar WordPress. 

En primer lugar nos logueamos en OpenShift. Una vez hecho esto elegimos la opción "Crear mi primera app". Nos saldrá una pantalla como la siguiente. En esta pantalla buscaremos Wordpress en el cuadro de búsqueda para instalarlo en nuestra app.

![Primera app en openshift](https://github.com/FranciscoPorcel/GII-2014/blob/master/ejercicios/FranciscoPorcel/imagenes/Tema2/3_1.png)

En la siguiente pantalla deberemos rellenar un formulario en el que se nos pedirá entre otras cosas el nombre de dominio de nuestra app:

![Primera app en openshift](https://github.com/FranciscoPorcel/GII-2014/blob/master/ejercicios/FranciscoPorcel/imagenes/Tema2/3_2.png)

Finalemte podemos observar como se ha creado el sitio con éxito:

![Primera app en openshift](https://github.com/FranciscoPorcel/GII-2014/blob/master/ejercicios/FranciscoPorcel/imagenes/Tema2/3_3.png)

Si entramos en el sitio web, podemos ver cómo podemos empezar a configurarlo:

![Primera app en openshift](https://github.com/FranciscoPorcel/GII-2014/blob/master/ejercicios/FranciscoPorcel/imagenes/Tema2/3_4.png)

Una vez realizada la configuración, accederemos como editores a la web y podremos comenzar a editarlo:

![Primera app en openshift](https://github.com/FranciscoPorcel/GII-2014/blob/master/ejercicios/FranciscoPorcel/imagenes/Tema2/3_5.png)


## Ejercicio 4

#### Crear un script para un documento Google y cambiarle el nombre con el que aparece en el menú, así como la función a la que llama. 

Lo primero que hacemos es clickear en Herramientas->Editor de secuencia de comandos... Una vez ahí podemos cambiarle el nombre al menú y definir una función:

![Editor de secuencia de comandos](https://github.com/FranciscoPorcel/GII-2014/blob/master/ejercicios/FranciscoPorcel/imagenes/Tema2/4_2.png)

Podemos clickear en la función creada (Hola mundo) y observar que funciona correctamente:

![Prueba de la función](https://github.com/FranciscoPorcel/GII-2014/blob/master/ejercicios/FranciscoPorcel/imagenes/Tema2/4_3.png)

##Ejercicio 5

#### Buscar un sistema de automatización de la construcción para el lenguaje de programación y entorno de desarrollo que usemos habitualmente.

Hasta ahora, el único sistema de automatización de la construcción para el lenguaje de programación y entorno de desarrollo que he usado ha sido Make. Se puede ver en las siguientes dos imágenes un ejemplo de él:

![Make 1](https://github.com/FranciscoPorcel/GII-2014/blob/master/ejercicios/FranciscoPorcel/imagenes/Tema2/5_1.png)

![Make 2](https://github.com/FranciscoPorcel/GII-2014/blob/master/ejercicios/FranciscoPorcel/imagenes/Tema2/5_2.png)

##Ejercicio 6

#### Identificar, dentro del PaaS elegido o cualquier otro en el que se dé uno de alta, cuál es el fichero de automatización de construcción e indicar qué herramienta usa para la construcción y el proceso que sigue en la misma. 

Ya que hemos usado Openshift voy a describir el fichero de automatización. Podemos saber cómo hacerlo desde la página oficial de Openshift:

[Openshift](https://developers.openshift.com/en/getting-started-client-tools.html#ubuntu)

En primer lugar escribimos:

sudo apt-get install ruby-full rubygems git-core
sudo gem install rhc

A continuación se instala rhc:

rhc setup

Y seguimos los pasos:

![Primer paso ](https://github.com/FranciscoPorcel/GII-2014/blob/master/ejercicios/FranciscoPorcel/imagenes/Tema2/6_1.png)


#Tema 3

##Ejercicio 1

#### Crear un espacio de nombres y montar en él una imagen ISO de un CD de forma que no se pueda leer más que desde él. Pista: en ServerFault nos explican como hacerlo, usando el dispositivo loopback

Simplemente tenemos que hacer:

![Ejercicio 1](https://github.com/FranciscoPorcel/GII-2014/blob/master/ejercicios/FranciscoPorcel/imagenes/Tema3/1.png)

Donde imagen es el fichero a montar.

##Ejercicio 2

#### 1. Mostrar los puentes configurados en el sistema operativo.

Lo hacemos mediante:

![Ejercicio 2](https://github.com/FranciscoPorcel/GII-2014/blob/master/ejercicios/FranciscoPorcel/imagenes/Tema3/2_1.png)

Como podemos observar no hay ninguno creado aún.

#### 2. Crear un interfaz virtual y asignarlo al interfaz de la tarjeta wifi, si se tiene, o del fijo, si no se tiene.

Para crear un interfaz virtual y asignarlo al interfaz de la tarjeta wifi hacemos lo siguiente:

Creamos interfaz virtual:

* sudo brctl addbr puenteEjercicio2

La asignamos al interfaz de la tarjeta wifi:

* sudo brctl addif puenteEjercicio2 wlan0

Se edita el fichero 

* /etc/networks/interfaces 

para configurar la nueva interfaz

Se añade un default gateway

* route add default gw [IP] nuevopuente 

Por último levantamos para que quede funcionando:

* sudo ifconfig puenteEjercicio2 up

##Ejercicio 3

#### 3.1 Usar debootstrap (o herramienta similar en otra distro) para crear un sistema mínimo que se pueda ejecutar más adelante.

En primer lugar instalamos debootstrap:

* sudo apt-get install debootstrap

Creamos un usuario llamado "jaulas".

* sudo debootstrap --arch=i386 saucy /home/jaulas/saucy32/ http://archive.ubuntu.com/ubuntu

Nos devolverá el siguiente mensaje:

I: Base system installed successfully.

#### 3.2 Experimentar con la creación de un sistema Fedora dentro de Debian usando Rinse.

Instalamos rinse y Fedora mediante:

sudo apt-get install rinse

sudo rinse --arch=amd64 --distribution fedora-core-6 --directory /home/jaulas/fedora/

Que devuelve:

''' Installed: dhclient.x86_64 12:3.0.5-5.fc6 Cleaning up Final tidy... Installation complete. '''

## Ejercicio 4 

#### Instalar alguna sistema debianita y configurarlo para su uso. Trabajando desde terminal, probar a ejecutar alguna aplicación o instalar las herramientas necesarias para compilar una y ejecutarla. 

Entramos en una de las jaulas creadas:

sudo chroot /home/jaulas/saucy32

Montamos "/proc":

mount -t proc proc /proc

Instalamos el paquete en español como se dice en la documentación de la práctica:

apt-get install language-pack-es

## Ejercicio 5

#### Instalar una jaula chroot para ejecutar el servidor web de altas prestaciones nginx.

Tendremos que añadir el repositorio de la siguiente forma:

* Se edita la lista de repositorios /etc/apt/sources.list
* Se añaden los repositorios: deb http://nginx.org/packages/ubuntu/ saucy nginx y deb-src http://nginx.org/packages/ubuntu/ saucy nginx
* Se descarga la clave del repositorio: wget http://nginx.org/keys/nginx_signing.key
* Se añade la clave apt-key: add nginx_signing.key
* Se actualiza la lista de repositorios: apt-get update
* Se instala nginx: apt-get install nginx
* Ejecutamos el servicio: service nginx start
* Se accede a "localhost" utilizando el navegador y se comprueba que funciona

## Ejercicio 6

#### Crear una jaula y enjaular un usuario usando `jailkit`, que previamente se habrá tenido que instalar. 

Accedemos a la página de ![jailkit](http://olivier.sessink.nl/jailkit/) y lo descargamos. A continuación hacemos lo siguiente:

* tar -xzvf jailkit-2.17.tar.gz
* cd jailkit-2.17
* sudo ./configure && make && sudo make install

Creamos una nueva jaula e iniciamos con jailkit: 
* sudo mkdir /home/jaulas/jailkit sudo jk_init -v -j /home/jaulas/jailkit jk_lsh basicshell netutils editors

Creamos un usuario y lo enjaulamos: 
* sudo adduser enjaulado 
* sudo jk_jailuser -m -j /home/jaulas/jailkit enjaulado

Tras esto, ya tendremos a nuestro usuario enjaulado.

# Tema 4

## Ejercicio 1

#### Instala LXC en tu versión de Linux favorita. Normalmente la versión en desarrollo, disponible tanto en GitHub como en el sitio web está bastante más avanzada; para evitar problemas sobre todo con las herramientas que vamos a ver más adelante, conviene que te instales la última versión y si es posible una igual o mayor a la 1.0.

Hay que realizar la instalación desde el repositorio:

![Ejercicio 1_1](https://github.com/FranciscoPorcel/GII-2014/blob/master/ejercicios/FranciscoPorcel/imagenes/Tema4/1_1.png)

Una vez hecho esto, será necesario comprobar si nuestra máquina es compatible utilizando el comando lxc-checkconfig

![Ejercicio 1_2](https://github.com/FranciscoPorcel/GII-2014/blob/master/ejercicios/FranciscoPorcel/imagenes/Tema4/1_2.png)

## Ejercicio 2

#### Comprobar qué interfaces puente se han creado y explicarlos.

Tras ejecutar ipconfig -a vemos que se ha creado el interfaz lxcbr0:

![Ejercicio 2_1](https://github.com/FranciscoPorcel/GII-2014/blob/master/ejercicios/FranciscoPorcel/imagenes/Tema4/2_1.png)

Con el comando "brctl show" veriamos que también está y el contenedor tiene acceso a la red.

![Ejercicio 2_2](https://github.com/FranciscoPorcel/GII-2014/blob/master/ejercicios/FranciscoPorcel/imagenes/Tema4/2_2.png)

## Ejercicio 3

#### Crear y ejecutar un contenedor basado en Debian. Crear y ejecutar un contenedor basado en otra distribución, tal como Fedora. Nota En general, crear un contenedor basado en tu distribución y otro basado en otra que no sea la tuya. Fedora, al parecer, tiene problemas si estás en Ubuntu 13.04 o superior, así que en tal caso usa cualquier otra distro. Por ejemplo, Óscar Zafra ha logrado instalar Gentoo usando un script descargado desde su sitio, como indica en este comentario en el issue.

Podemos crearlos con:

* sudo lxc-create -t debian -n minube_debian
* sudo lxc-start -n minube_debian

Y obtenemos:

![Ejercicio 3_1](https://github.com/FranciscoPorcel/GII-2014/blob/master/ejercicios/FranciscoPorcel/imagenes/Tema4/3_1.png)

## Ejercicio 4

#### Instalar lxc-webpanel y usarlo para arrancar, parar y visualizar las máquinas virtuales que se tengan instaladas.

Lo instalamos con: wget http://lxc-webpanel.github.io/tools/install.sh -O - | sudo bash

![Ejercicio 4_1](https://github.com/FranciscoPorcel/GII-2014/blob/master/ejercicios/FranciscoPorcel/imagenes/Tema4/4_1.png)

Después accedemos a http://localhost:5000 :

![Ejercicio 4_2](https://github.com/FranciscoPorcel/GII-2014/blob/master/ejercicios/FranciscoPorcel/imagenes/Tema4/4_2.png)

#### Desde el panel restringir los recursos que pueden usar: CPU shares, CPUs que se pueden usar (en sistemas multinúcleo) o cantidad de memoria.

Todo esto podemos hacerlo en la siguiente pestaña:

![Ejercicio 4_3](https://github.com/FranciscoPorcel/GII-2014/blob/master/ejercicios/FranciscoPorcel/imagenes/Tema4/4_3.png)

## Ejercicio 6

#### Instalar juju.

Para instalarlo ejecutamos:

* sudo add-apt-repository ppa:juju/stable
* sudo apt-get update
* sudo apt-get install juju-core

![Ejercicio 6_1](https://github.com/FranciscoPorcel/GII-2014/blob/master/ejercicios/FranciscoPorcel/imagenes/Tema4/6_1.png)

## Ejercicio 7

#### Destruir toda la configuración creada anteriormente

Ejecutamos:

* juju destroy-service mysql
* juju destroy-service mediawiki
* sudo juju destroy-environment local

#### Volver a crear la máquina anterior y añadirle mediawiki y una relación entre ellos.

La creamos mediante las órdenes:

* juju bootstrap
* juju deploy mediawiki
* juju deploy mysql
* juju add-relation mediawiki:db mysql
* juju expose mediawiki

## Ejercicio 8

#### Instalar libvirt. Te puede ayudar esta guía para Ubuntu. 

Ejecutamos:

![Ejercicio 8_1](https://github.com/FranciscoPorcel/GII-2014/blob/master/ejercicios/FranciscoPorcel/imagenes/Tema4/8_1.png)

Una vez hecho esto, comprobamos con kvm-ok que todo está correcto.




















